{% extends "base.html" %}

{% block title %}LLMeetCode{% endblock %}

{% block head %}
<style>
    #editor {
        height: 400px;
        border-radius: 8px;
        overflow: hidden;
    }
    .test-result {
        padding: 8px 12px;
        border-radius: 4px;
        font-family: monospace;
        font-size: 0.875rem;
    }
    .test-pass { background: #166534; color: #86efac; }
    .test-fail { background: #991b1b; color: #fca5a5; }
    .test-hidden { opacity: 0.7; }
    
    /* Chat Panel Styles */
    .chat-panel {
        position: fixed;
        right: 0;
        top: 0;
        height: 100vh;
        width: 380px;
        background: #1f2937;
        border-left: 1px solid #374151;
        transform: translateX(100%);
        transition: transform 0.3s ease;
        z-index: 50;
        display: flex;
        flex-direction: column;
    }
    .chat-panel.open { transform: translateX(0); }
    .chat-toggle {
        position: fixed;
        right: 20px;
        bottom: 20px;
        width: 56px;
        height: 56px;
        border-radius: 50%;
        background: #8b5cf6;
        color: white;
        border: none;
        cursor: pointer;
        box-shadow: 0 4px 12px rgba(139, 92, 246, 0.4);
        z-index: 49;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    .chat-toggle:hover { background: #7c3aed; transform: scale(1.05); }
    .chat-toggle.open { right: 400px; }
    .chat-header {
        padding: 16px;
        border-bottom: 1px solid #374151;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    .chat-messages {
        flex: 1;
        overflow-y: auto;
        padding: 16px;
        display: flex;
        flex-direction: column;
        gap: 12px;
    }
    .chat-message {
        max-width: 90%;
        padding: 10px 14px;
        border-radius: 12px;
        font-size: 0.875rem;
        line-height: 1.5;
    }
    .chat-message.user {
        align-self: flex-end;
        background: #8b5cf6;
        color: white;
        border-bottom-right-radius: 4px;
    }
    .chat-message.assistant {
        align-self: flex-start;
        background: #374151;
        color: #e5e7eb;
        border-bottom-left-radius: 4px;
    }
    .chat-message pre {
        background: #111827;
        padding: 8px;
        border-radius: 6px;
        overflow-x: auto;
        margin: 8px 0;
    }
    .chat-message code {
        font-family: 'Monaco', 'Menlo', monospace;
        font-size: 0.8rem;
    }
    .chat-input-area {
        padding: 16px;
        border-top: 1px solid #374151;
    }
    .quick-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        padding: 8px 16px;
        border-top: 1px solid #374151;
    }
    .quick-action-btn {
        background: #374151;
        color: #d1d5db;
        border: 1px solid #4b5563;
        border-radius: 16px;
        padding: 4px 12px;
        font-size: 0.75rem;
        cursor: pointer;
        transition: all 0.15s;
    }
    .quick-action-btn:hover {
        background: #4b5563;
        border-color: #6b7280;
        color: white;
    }
    .chat-input-wrapper {
        display: flex;
        gap: 8px;
    }
    .chat-input {
        flex: 1;
        background: #111827;
        border: 1px solid #374151;
        border-radius: 8px;
        padding: 10px 14px;
        color: white;
        font-size: 0.875rem;
        resize: none;
    }
    .chat-input:focus { outline: none; border-color: #8b5cf6; }
    .chat-send {
        background: #8b5cf6;
        color: white;
        border: none;
        border-radius: 8px;
        padding: 10px 16px;
        cursor: pointer;
        font-weight: 500;
    }
    .chat-send:hover { background: #7c3aed; }
    .chat-send:disabled { opacity: 0.5; cursor: not-allowed; }
    .chat-typing {
        display: flex;
        gap: 4px;
        padding: 10px 14px;
        background: #374151;
        border-radius: 12px;
        align-self: flex-start;
        border-bottom-left-radius: 4px;
    }
    .chat-typing span {
        width: 8px;
        height: 8px;
        background: #9ca3af;
        border-radius: 50%;
        animation: typing 1.4s infinite;
    }
    .chat-typing span:nth-child(2) { animation-delay: 0.2s; }
    .chat-typing span:nth-child(3) { animation-delay: 0.4s; }
    @keyframes typing {
        0%, 60%, 100% { transform: translateY(0); }
        30% { transform: translateY(-4px); }
    }
    
    .streaming-cursor {
        animation: blink 1s infinite;
        color: #8b5cf6;
    }
    @keyframes blink {
        0%, 50% { opacity: 1; }
        51%, 100% { opacity: 0; }
    }
    .markdown-content pre {
        background: #1f2937;
        padding: 1rem;
        border-radius: 0.5rem;
        overflow-x: auto;
    }
    .markdown-content code {
        font-family: 'Monaco', 'Menlo', monospace;
        font-size: 0.875rem;
    }
    .markdown-content p { margin-bottom: 0.75rem; }
    .markdown-content ul { list-style: disc; margin-left: 1.5rem; margin-bottom: 0.75rem; }
    .markdown-content strong { color: #f3f4f6; }
</style>
{% endblock %}

{% block content %}
<div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
    <!-- Left: Problem Description -->
    <div class="bg-gray-800 rounded-lg p-6">
        <div class="flex items-center gap-3 mb-4">
            <span class="type-badge type-{{ problem.type|lower|replace(' ', '-')|replace('jira ticket', 'jira')|replace('support request', 'support')|replace('bug report', 'bug') }}">
                {{ problem.type }}
            </span>
            <span class="text-xs text-gray-500">Priority: {{ problem.priority }}</span>
        </div>
        
        <h1 class="text-2xl font-bold text-white mb-2">{{ problem.title }}</h1>
        <p class="text-xs text-gray-500 mb-6">Reporter: {{ problem.reporter }}</p>
        
        <div class="markdown-content text-gray-300 prose prose-invert max-w-none">
            {{ problem.description | safe }}
        </div>
        
        <div class="mt-6 pt-6 border-t border-gray-700">
            <h3 class="text-sm font-semibold text-gray-400 mb-3">Test Cases ({{ problem.tests|length }} total)</h3>
            <div class="space-y-2">
                {% for test in problem.tests %}
                {% if not test.hidden %}
                <div class="bg-gray-900 rounded p-3 font-mono text-sm">
                    <div class="text-gray-400">Input: <span class="text-blue-400">{{ test.input }}</span></div>
                    <div class="text-gray-400">Expected: <span class="text-green-400">{{ test.expected }}</span></div>
                </div>
                {% endif %}
                {% endfor %}
                {% set hidden_count = problem.tests | selectattr('hidden') | list | length %}
                {% if hidden_count > 0 %}
                <p class="text-xs text-gray-500 italic">+ {{ hidden_count }} hidden test(s)</p>
                {% endif %}
            </div>
        </div>
    </div>
    
    <!-- Right: Code Editor & Results -->
    <div class="space-y-4">
        <div class="bg-gray-800 rounded-lg p-4">
            <div class="flex items-center justify-between mb-3">
                <span class="text-sm text-gray-400">solution.py</span>
                <button id="reset-btn" class="text-xs text-gray-500 hover:text-gray-300">Reset Code</button>
            </div>
            <div id="editor"></div>
        </div>
        
        <button id="submit-btn" class="w-full bg-green-600 hover:bg-green-700 text-white font-semibold py-3 px-6 rounded-lg transition-colors flex items-center justify-center gap-2">
            <span>Submit Solution</span>
            <span id="submit-spinner" class="hidden">
                <svg class="animate-spin h-5 w-5" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4" fill="none"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
            </span>
        </button>
        
        <div id="results" class="bg-gray-800 rounded-lg p-4 hidden">
            <h3 class="text-lg font-semibold mb-3">Results</h3>
            <div id="results-list" class="space-y-2"></div>
            <div id="results-summary" class="mt-4 pt-4 border-t border-gray-700 text-center"></div>
        </div>
        
        <!-- Submission History -->
        <div id="history" class="bg-gray-800 rounded-lg p-4">
            <h3 class="text-lg font-semibold mb-3">Submission History</h3>
            <div id="history-list" class="space-y-2">
                {% if submissions %}
                    {% for sub in submissions|reverse %}
                    <div class="flex items-center justify-between p-2 rounded {{ 'bg-green-900/30' if sub.passed else 'bg-red-900/30' }}">
                        <span class="text-sm font-mono text-gray-400">#{{ loop.revindex }}</span>
                        <span class="text-sm">
                            {% set pass_count = sub.results|selectattr('passed')|list|length %}
                            {{ pass_count }}/{{ sub.results|length }} tests
                        </span>
                        <span class="{{ 'text-green-400' if sub.passed else 'text-red-400' }}">
                            {{ 'âœ“ Passed' if sub.passed else 'âœ— Failed' }}
                        </span>
                    </div>
                    {% endfor %}
                {% else %}
                    <p class="text-gray-500 text-sm italic">No submissions yet</p>
                {% endif %}
            </div>
        </div>
    </div>
</div>

<!-- Chat Toggle Button -->
<button id="chat-toggle" class="chat-toggle" title="Chat with AI">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
    </svg>
</button>

<!-- Chat Panel -->
<div id="chat-panel" class="chat-panel">
    <div class="chat-header">
        <div>
            <h3 class="font-semibold text-white">AI Assistant</h3>
            <p class="text-xs text-gray-400">Powered by Gemini</p>
        </div>
        <button id="clear-chat" class="text-xs text-gray-400 hover:text-white">Clear</button>
    </div>
    <div id="chat-messages" class="chat-messages">
        <div class="chat-message assistant">
            Hi! I'm here to help you solve this problem. Ask me anything about the requirements, your approach, or if you're stuck on something.
        </div>
    </div>
    <div class="quick-actions">
        <button class="quick-action-btn" data-prompt="Explain this problem in simple terms">Explain problem</button>
        <button class="quick-action-btn" data-prompt="Give me a hint without revealing the full solution">Give hint</button>
        <button class="quick-action-btn" data-prompt="Review my current code and suggest improvements">Review code</button>
        <button class="quick-action-btn" data-prompt="Why might my tests be failing? Analyze my approach.">Debug help</button>
    </div>
    <div class="chat-input-area">
        <div class="chat-input-wrapper">
            <textarea id="chat-input" class="chat-input" placeholder="Ask about the problem... (Cmd/Ctrl+Shift+C to toggle)" rows="1"></textarea>
            <button id="chat-send" class="chat-send">Send</button>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script id="problem-data" type="application/json">
{
    "id": {{ problem.id | tojson }},
    "starterCode": {{ problem.starter_code | tojson }},
    "submissionCount": {{ submissions|length }}
}
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs/loader.min.js"></script>
<script>
    const problemData = JSON.parse(document.getElementById('problem-data').textContent);
    const problemId = problemData.id;
    const starterCode = problemData.starterCode;
    
    let editor;
    
    require.config({ paths: { vs: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs' } });
    
    require(['vs/editor/editor.main'], function () {
        monaco.editor.defineTheme('llmeetcode', {
            base: 'vs-dark',
            inherit: true,
            rules: [],
            colors: {
                'editor.background': '#111827',
            }
        });
        
        editor = monaco.editor.create(document.getElementById('editor'), {
            value: starterCode,
            language: 'python',
            theme: 'llmeetcode',
            minimap: { enabled: false },
            fontSize: 14,
            lineNumbers: 'on',
            scrollBeyondLastLine: false,
            automaticLayout: true,
            padding: { top: 16, bottom: 16 },
            inlineSuggest: { 
                enabled: true,
                mode: 'subwordSmart'
            },
            quickSuggestions: false,
            suggestOnTriggerCharacters: false
        });
        
        // Ghost text inline completions with debouncing
        let completionDebounceTimer = null;
        let currentCompletionRequest = null;
        let lastCompletionPosition = null;
        const DEBOUNCE_DELAY = 400; // ms
        
        monaco.languages.registerInlineCompletionsProvider('python', {
            provideInlineCompletions: async (model, position, context, token) => {
                // Clear any pending debounce timer
                if (completionDebounceTimer) {
                    clearTimeout(completionDebounceTimer);
                    completionDebounceTimer = null;
                }
                
                // Cancel previous request if still pending
                if (currentCompletionRequest) {
                    currentCompletionRequest.abort();
                    currentCompletionRequest = null;
                }
                
                const fullText = model.getValue();
                const offset = model.getOffsetAt(position);
                const codeBefore = fullText.substring(0, offset);
                const codeAfter = fullText.substring(offset);
                
                // Skip if cursor is at start or just whitespace before
                if (codeBefore.trim().length < 5) {
                    return { items: [] };
                }
                
                // Skip if inside a string or comment (basic check)
                const currentLine = model.getLineContent(position.lineNumber);
                const beforeCursor = currentLine.substring(0, position.column - 1);
                const quoteCount = (beforeCursor.match(/["']/g) || []).length;
                if (quoteCount % 2 !== 0) {
                    return { items: [] }; // Inside a string
                }
                if (beforeCursor.trim().startsWith('#')) {
                    return { items: [] }; // Inside a comment
                }
                
                // Debounce: wait before making the request
                return new Promise((resolve) => {
                    completionDebounceTimer = setTimeout(async () => {
                        // Check if cancelled
                        if (token.isCancellationRequested) {
                            resolve({ items: [] });
                            return;
                        }
                        
                        try {
                            const controller = new AbortController();
                            currentCompletionRequest = controller;
                            
                            const response = await fetch(`/complete/${problemId}`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    code_before: codeBefore,
                                    code_after: codeAfter
                                }),
                                signal: controller.signal
                            });
                            
                            currentCompletionRequest = null;
                            
                            if (!response.ok || token.isCancellationRequested) {
                                resolve({ items: [] });
                                return;
                            }
                            
                            const data = await response.json();
                            
                            if (data.completion && data.completion.trim()) {
                                resolve({
                                    items: [{
                                        insertText: data.completion,
                                        range: {
                                            startLineNumber: position.lineNumber,
                                            startColumn: position.column,
                                            endLineNumber: position.lineNumber,
                                            endColumn: position.column
                                        }
                                    }]
                                });
                            } else {
                                resolve({ items: [] });
                            }
                        } catch (error) {
                            if (error.name !== 'AbortError') {
                                console.error('Completion error:', error);
                            }
                            currentCompletionRequest = null;
                            resolve({ items: [] });
                        }
                    }, DEBOUNCE_DELAY);
                });
            },
            freeInlineCompletions: (completions) => {
                // Cleanup if needed
            }
        });
        
        // Keyboard shortcut: Ctrl+Space to manually trigger inline suggestions
        editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Space, () => {
            editor.trigger('keyboard', 'editor.action.inlineSuggest.trigger', {});
        });
    });
    
    document.getElementById('reset-btn').addEventListener('click', () => {
        if (confirm('Reset code to starter template?')) {
            editor.setValue(starterCode);
        }
    });
    
    document.getElementById('submit-btn').addEventListener('click', async () => {
        const btn = document.getElementById('submit-btn');
        const spinner = document.getElementById('submit-spinner');
        const resultsDiv = document.getElementById('results');
        const resultsList = document.getElementById('results-list');
        const resultsSummary = document.getElementById('results-summary');
        
        btn.disabled = true;
        spinner.classList.remove('hidden');
        
        try {
            const response = await fetch(`/submit/${problemId}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ code: editor.getValue() })
            });
            
            const data = await response.json();
            
            resultsDiv.classList.remove('hidden');
            resultsList.innerHTML = '';
            
            let passCount = 0;
            data.test_results.forEach((result, i) => {
                if (result.passed) passCount++;
                const div = document.createElement('div');
                div.className = `test-result ${result.passed ? 'test-pass' : 'test-fail'} ${result.hidden ? 'test-hidden' : ''}`;
                div.innerHTML = `
                    <span class="font-semibold">${result.hidden ? 'Hidden Test' : 'Test'} ${i + 1}:</span>
                    ${result.passed ? 'âœ“ Passed' : 'âœ— ' + result.message}
                `;
                resultsList.appendChild(div);
            });
            
            const allPassed = data.all_passed;
            resultsSummary.innerHTML = allPassed
                ? '<span class="text-2xl">ðŸŽ‰</span> <span class="text-green-400 font-bold">All tests passed!</span>'
                : `<span class="text-yellow-400">${passCount}/${data.test_results.length} tests passed</span>`;
            
            // Update submission history
            updateHistory(allPassed, passCount, data.test_results.length);
                
        } catch (error) {
            resultsDiv.classList.remove('hidden');
            resultsList.innerHTML = `<div class="test-result test-fail">Error: ${error.message}</div>`;
            resultsSummary.innerHTML = '';
        } finally {
            btn.disabled = false;
            spinner.classList.add('hidden');
        }
    });
    
    let submissionCount = problemData.submissionCount;
    
    function updateHistory(passed, passCount, totalTests) {
        submissionCount++;
        const historyList = document.getElementById('history-list');
        
        // Remove "No submissions yet" message if present
        const emptyMsg = historyList.querySelector('p');
        if (emptyMsg) emptyMsg.remove();
        
        // Add new submission at the top
        const div = document.createElement('div');
        div.className = `flex items-center justify-between p-2 rounded ${passed ? 'bg-green-900/30' : 'bg-red-900/30'}`;
        div.innerHTML = `
            <span class="text-sm font-mono text-gray-400">#${submissionCount}</span>
            <span class="text-sm">${passCount}/${totalTests} tests</span>
            <span class="${passed ? 'text-green-400' : 'text-red-400'}">
                ${passed ? 'âœ“ Passed' : 'âœ— Failed'}
            </span>
        `;
        historyList.insertBefore(div, historyList.firstChild);
    }
    
    // Chat functionality
    const chatToggle = document.getElementById('chat-toggle');
    const chatPanel = document.getElementById('chat-panel');
    const chatMessages = document.getElementById('chat-messages');
    const chatInput = document.getElementById('chat-input');
    const chatSend = document.getElementById('chat-send');
    const clearChat = document.getElementById('clear-chat');
    
    function toggleChat() {
        chatPanel.classList.toggle('open');
        chatToggle.classList.toggle('open');
    }
    
    chatToggle.addEventListener('click', toggleChat);
    
    function addMessage(content, role) {
        const div = document.createElement('div');
        div.className = `chat-message ${role === 'user' ? 'user' : 'assistant'}`;
        div.innerHTML = formatMarkdown(content);
        chatMessages.appendChild(div);
        chatMessages.scrollTop = chatMessages.scrollHeight;
    }
    
    function formatMarkdown(text) {
        // Basic markdown formatting for code blocks
        return text
            .replace(/```(\w*)\n([\s\S]*?)```/g, '<pre><code>$2</code></pre>')
            .replace(/`([^`]+)`/g, '<code>$1</code>')
            .replace(/\n/g, '<br>');
    }
    
    function showTyping() {
        const div = document.createElement('div');
        div.className = 'chat-typing';
        div.id = 'typing-indicator';
        div.innerHTML = '<span></span><span></span><span></span>';
        chatMessages.appendChild(div);
        chatMessages.scrollTop = chatMessages.scrollHeight;
    }
    
    function hideTyping() {
        const typing = document.getElementById('typing-indicator');
        if (typing) typing.remove();
    }
    
    async function sendMessage() {
        const message = chatInput.value.trim();
        if (!message) return;
        
        chatInput.value = '';
        chatSend.disabled = true;
        
        addMessage(message, 'user');
        
        // Create streaming message element
        const streamDiv = document.createElement('div');
        streamDiv.className = 'chat-message assistant';
        streamDiv.innerHTML = '<span class="streaming-cursor">â–Š</span>';
        chatMessages.appendChild(streamDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight;
        
        let fullResponse = '';
        
        try {
            const response = await fetch(`/chat/stream/${problemId}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    message: message,
                    code: editor.getValue()
                })
            });
            
            if (!response.ok) {
                const errorData = await response.json();
                streamDiv.innerHTML = formatMarkdown('Sorry, I encountered an error: ' + (errorData.error || 'Unknown error'));
                return;
            }
            
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            
            while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                
                const text = decoder.decode(value);
                const lines = text.split('\n');
                
                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        try {
                            const data = JSON.parse(line.slice(6));
                            if (data.chunk) {
                                fullResponse += data.chunk;
                                streamDiv.innerHTML = formatMarkdown(fullResponse) + '<span class="streaming-cursor">â–Š</span>';
                                chatMessages.scrollTop = chatMessages.scrollHeight;
                            }
                            if (data.done) {
                                streamDiv.innerHTML = formatMarkdown(fullResponse);
                                // Save to chat history
                                await fetch(`/chat/save/${problemId}`, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({
                                        user_message: message,
                                        assistant_response: fullResponse
                                    })
                                });
                            }
                        } catch (e) {
                            // Skip invalid JSON
                        }
                    }
                }
            }
        } catch (error) {
            streamDiv.innerHTML = formatMarkdown('Sorry, I encountered an error: ' + error.message);
        } finally {
            chatSend.disabled = false;
            chatInput.focus();
        }
    }
    
    chatSend.addEventListener('click', sendMessage);
    chatInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
        }
    });
    
    clearChat.addEventListener('click', async () => {
        if (!confirm('Clear chat history?')) return;
        
        try {
            await fetch(`/chat/clear/${problemId}`, { method: 'POST' });
            chatMessages.innerHTML = `
                <div class="chat-message assistant">
                    Hi! I'm here to help you solve this problem. Ask me anything about the requirements, your approach, or if you're stuck on something.
                </div>
            `;
        } catch (error) {
            console.error('Failed to clear chat:', error);
        }
    });
    
    // Load chat history on page load
    async function loadChatHistory() {
        try {
            const response = await fetch(`/chat/history/${problemId}`);
            const history = await response.json();
            
            if (history.length > 0) {
                chatMessages.innerHTML = '';
                history.forEach(msg => {
                    addMessage(msg.content, msg.role === 'user' ? 'user' : 'assistant');
                });
            }
        } catch (error) {
            console.error('Failed to load chat history:', error);
        }
    }
    
    loadChatHistory();
    
    // Quick action buttons
    document.querySelectorAll('.quick-action-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const prompt = btn.dataset.prompt;
            if (prompt) {
                chatInput.value = prompt;
                sendMessage();
            }
        });
    });
    
    // Keyboard shortcut: Cmd/Ctrl + Shift + C to toggle chat
    document.addEventListener('keydown', (e) => {
        if ((e.metaKey || e.ctrlKey) && e.shiftKey && e.key.toLowerCase() === 'c') {
            e.preventDefault();
            toggleChat();
            if (chatPanel.classList.contains('open')) {
                chatInput.focus();
            }
        }
    });
</script>
{% endblock %}
